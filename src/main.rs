
// autogenerated from proto files

use std::convert::Infallible;

pub struct AddLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

pub struct RemoveLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
}

pub struct GetShoppingCart {
    // message fields
    pub user_id: ::std::string::String,
}

// this also used in events

trait Message {}

#[derive(PartialEq,Clone,Default)]
pub struct LineItem {
    // message fields
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

// this also used as a state snapshot
pub struct Cart {
    // message fields
    // pub items: ::protobuf::RepeatedField<LineItem>,
    pub items: Vec<LineItem>,
}

impl Message for Cart {}


// autogenerated events, state (for snapshots)

pub struct ItemAdded {
    // message fields
    // pub item: ::protobuf::SingularPtrField<LineItem>,
    pub item: Option<LineItem>,
}

impl Message for ItemAdded {}

pub struct ItemRemoved {
    // message fields
    pub productId: ::std::string::String,
}

impl Message for ItemRemoved {}


// user defined command and event handlers

struct Context {}

impl Context {
    fn persist_event<T: Message>(&mut self, event: T) {}
}

// entity state
struct ShopCart {
    items: Vec<LineItem>,
}

// command handler
impl ShopCart {

    // command handler
    fn add_item(self: &ShopCart, item: LineItem, ctx: &mut Context) {
        //NOTE. cart is read only
        let evt = ItemAdded {
            item: Some(item),
        };
        ctx.persist_event(evt);
    }

    // read-only command handler
    fn get_cart(self: &ShopCart) -> Cart {
        Cart {
            items: self.items.clone() // need to clone, maybe return a reference somehow?
        }
    }

    // initial empty state
    fn empty() -> Cart {
        Cart {
            items : vec!(),
        }
    }

    // init state out of the snapshot
    fn init(cart: Cart) -> ShopCart {
        ShopCart {
            items : cart.items,
        }
    }

    // event handler
    fn item_added(self: &mut ShopCart, event: ItemAdded) {
        if let Some(item) = event.item {
            //TODO find if it already exists
            self.items.push(item);
        }
    }

    // event handler
    fn item_removed(self: &mut ShopCart, event: ItemRemoved) {
        //TODO find and remove item by event.productId
    }
}

struct Entity {}

impl Entity {

}

fn main() {


}
