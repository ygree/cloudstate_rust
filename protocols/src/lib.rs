// TODO: Now this modules put together manually out of auto-generated sources. How to make it automatically?

pub mod cloudstate {

    /// A reply to the sender.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reply {
        /// The reply payload
        #[prost(message, optional, tag = "1")]
        pub payload: ::std::option::Option<::prost_types::Any>,
    }
    /// Forwards handling of this request to another entity.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Forward {
        /// The name of the service to forward to.
        #[prost(string, tag = "1")]
        pub service_name: std::string::String,
        /// The name of the command.
        #[prost(string, tag = "2")]
        pub command_name: std::string::String,
        /// The payload.
        #[prost(message, optional, tag = "3")]
        pub payload: ::std::option::Option<::prost_types::Any>,
    }
    /// An action for the client
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClientAction {
        #[prost(oneof = "client_action::Action", tags = "1, 2, 3")]
        pub action: ::std::option::Option<client_action::Action>,
    }
    pub mod client_action {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Action {
            /// Send a reply
            #[prost(message, tag = "1")]
            Reply(super::Reply),
            /// Forward to another entity
            #[prost(message, tag = "2")]
            Forward(super::Forward),
            /// Send a failure to the client
            #[prost(message, tag = "3")]
            Failure(super::Failure),
        }
    }
    /// A side effect to be done after this command is handled.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SideEffect {
        /// The name of the service to perform the side effect on.
        #[prost(string, tag = "1")]
        pub service_name: std::string::String,
        /// The name of the command.
        #[prost(string, tag = "2")]
        pub command_name: std::string::String,
        /// The payload of the command.
        #[prost(message, optional, tag = "3")]
        pub payload: ::std::option::Option<::prost_types::Any>,
        /// Whether this side effect should be performed synchronously, ie, before the reply is eventually
        /// sent, or not.
        #[prost(bool, tag = "4")]
        pub synchronous: bool,
    }
    /// A command. For each command received, a reply must be sent with a matching command id.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Command {
        /// The ID of the entity.
        #[prost(string, tag = "1")]
        pub entity_id: std::string::String,
        /// A command id.
        #[prost(int64, tag = "2")]
        pub id: i64,
        /// Command name
        #[prost(string, tag = "3")]
        pub name: std::string::String,
        /// The command payload.
        #[prost(message, optional, tag = "4")]
        pub payload: ::std::option::Option<::prost_types::Any>,
        /// Whether the command is streamed or not
        #[prost(bool, tag = "5")]
        pub streamed: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StreamCancelled {
        /// The ID of the entity
        #[prost(string, tag = "1")]
        pub entity_id: std::string::String,
        /// The command id
        #[prost(int64, tag = "2")]
        pub id: i64,
    }
    /// A failure reply. If this is returned, it will be translated into a gRPC unknown
    /// error with the corresponding description if supplied.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Failure {
        /// The id of the command being replied to. Must match the input command.
        #[prost(int64, tag = "1")]
        pub command_id: i64,
        /// A description of the error.
        #[prost(string, tag = "2")]
        pub description: std::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntitySpec {
        /// This should be the Descriptors.FileDescriptorSet in proto serialized from as generated by:
        /// protoc --include_imports \
        /// --proto_path=<proto file directory> \
        /// --descriptor_set_out=user-function.desc \
        /// <path to .proto files>
        #[prost(bytes, tag = "1")]
        pub proto: std::vec::Vec<u8>,
        /// The entities being served.
        #[prost(message, repeated, tag = "2")]
        pub entities: ::std::vec::Vec<Entity>,
        /// Optional information about the service.
        #[prost(message, optional, tag = "3")]
        pub service_info: ::std::option::Option<ServiceInfo>,
    }
    /// Information about the service that proxy is proxying to.
    /// All of the information in here is optional. It may be useful for debug purposes.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ServiceInfo {
        /// The name of the service, eg, "shopping-cart".
        #[prost(string, tag = "1")]
        pub service_name: std::string::String,
        /// The version of the service.
        #[prost(string, tag = "2")]
        pub service_version: std::string::String,
        /// A description of the runtime for the service. Can be anything, but examples might be:
        /// - node v10.15.2
        /// - OpenJDK Runtime Environment 1.8.0_192-b12
        #[prost(string, tag = "3")]
        pub service_runtime: std::string::String,
        /// If using a support library, the name of that library, eg "cloudstate"
        #[prost(string, tag = "4")]
        pub support_library_name: std::string::String,
        /// The version of the support library being used.
        #[prost(string, tag = "5")]
        pub support_library_version: std::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entity {
        /// The type of entity. By convention, this should be a fully qualified entity protocol grpc
        /// service name, for example, cloudstate.eventsourced.EventSourced.
        #[prost(string, tag = "1")]
        pub entity_type: std::string::String,
        /// The name of the service to load from the protobuf file.
        #[prost(string, tag = "2")]
        pub service_name: std::string::String,
        /// The ID to namespace state by. How this is used depends on the type of entity, for example,
        /// event sourced entities will prefix this to the persistence id.
        #[prost(string, tag = "3")]
        pub persistence_id: std::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UserFunctionError {
        #[prost(string, tag = "1")]
        pub message: std::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProxyInfo {
        #[prost(int32, tag = "1")]
        pub protocol_major_version: i32,
        #[prost(int32, tag = "2")]
        pub protocol_minor_version: i32,
        #[prost(string, tag = "3")]
        pub proxy_name: std::string::String,
        #[prost(string, tag = "4")]
        pub proxy_version: std::string::String,
        #[prost(string, repeated, tag = "5")]
        pub supported_entity_types: ::std::vec::Vec<std::string::String>,
    }
    #[doc = r" Generated server implementations."]
    pub mod entity_discovery_server {
        #![allow(unused_variables, dead_code, missing_docs)]
        use tonic::codegen::*;
        #[doc = "Generated trait containing gRPC methods that should be implemented for use with EntityDiscoveryServer."]
        #[async_trait]
        pub trait EntityDiscovery: Send + Sync + 'static {
            #[doc = " Discover what entities the user function wishes to serve."]
            async fn discover(
                &self,
                request: tonic::Request<super::ProxyInfo>,
            ) -> Result<tonic::Response<super::EntitySpec>, tonic::Status>;
            #[doc = " Report an error back to the user function. This will only be invoked to tell the user function"]
            #[doc = " that it has done something wrong, eg, violated the protocol, tried to use an entity type that"]
            #[doc = " isn't supported, or attempted to forward to an entity that doesn't exist, etc. These messages"]
            #[doc = " should be logged clearly for debugging purposes."]
            async fn report_error(
                &self,
                request: tonic::Request<super::UserFunctionError>,
            ) -> Result<tonic::Response<()>, tonic::Status>;
        }
        #[doc = " Entity discovery service."]
        #[derive(Debug)]
        #[doc(hidden)]
        pub struct EntityDiscoveryServer<T: EntityDiscovery> {
            inner: _Inner<T>,
        }
        struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
        impl<T: EntityDiscovery> EntityDiscoveryServer<T> {
            pub fn new(inner: T) -> Self {
                let inner = Arc::new(inner);
                let inner = _Inner(inner, None);
                Self { inner }
            }
            pub fn with_interceptor(inner: T, interceptor: impl Into<tonic::Interceptor>) -> Self {
                let inner = Arc::new(inner);
                let inner = _Inner(inner, Some(interceptor.into()));
                Self { inner }
            }
        }
        impl<T, B> Service<http::Request<B>> for EntityDiscoveryServer<T>
        where
            T: EntityDiscovery,
            B: HttpBody + Send + Sync + 'static,
            B::Error: Into<StdError> + Send + 'static,
        {
            type Response = http::Response<tonic::body::BoxBody>;
            type Error = Never;
            type Future = BoxFuture<Self::Response, Self::Error>;
            fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                Poll::Ready(Ok(()))
            }
            fn call(&mut self, req: http::Request<B>) -> Self::Future {
                let inner = self.inner.clone();
                match req.uri().path() {
                    "/cloudstate.EntityDiscovery/discover" => {
                        #[allow(non_camel_case_types)]
                        struct discoverSvc<T: EntityDiscovery>(pub Arc<T>);
                        impl<T: EntityDiscovery> tonic::server::UnaryService<super::ProxyInfo> for discoverSvc<T> {
                            type Response = super::EntitySpec;
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                            fn call(
                                &mut self,
                                request: tonic::Request<super::ProxyInfo>,
                            ) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { inner.discover(request).await };
                                Box::pin(fut)
                            }
                        }
                        let inner = self.inner.clone();
                        let fut = async move {
                            let interceptor = inner.1.clone();
                            let inner = inner.0;
                            let method = discoverSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = if let Some(interceptor) = interceptor {
                                tonic::server::Grpc::with_interceptor(codec, interceptor)
                            } else {
                                tonic::server::Grpc::new(codec)
                            };
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    "/cloudstate.EntityDiscovery/reportError" => {
                        #[allow(non_camel_case_types)]
                        struct reportErrorSvc<T: EntityDiscovery>(pub Arc<T>);
                        impl<T: EntityDiscovery>
                            tonic::server::UnaryService<super::UserFunctionError>
                            for reportErrorSvc<T>
                        {
                            type Response = ();
                            type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                            fn call(
                                &mut self,
                                request: tonic::Request<super::UserFunctionError>,
                            ) -> Self::Future {
                                let inner = self.0.clone();
                                let fut = async move { inner.report_error(request).await };
                                Box::pin(fut)
                            }
                        }
                        let inner = self.inner.clone();
                        let fut = async move {
                            let interceptor = inner.1.clone();
                            let inner = inner.0;
                            let method = reportErrorSvc(inner);
                            let codec = tonic::codec::ProstCodec::default();
                            let mut grpc = if let Some(interceptor) = interceptor {
                                tonic::server::Grpc::with_interceptor(codec, interceptor)
                            } else {
                                tonic::server::Grpc::new(codec)
                            };
                            let res = grpc.unary(method, req).await;
                            Ok(res)
                        };
                        Box::pin(fut)
                    }
                    _ => Box::pin(async move {
                        Ok(http::Response::builder()
                            .status(200)
                            .header("grpc-status", "12")
                            .body(tonic::body::BoxBody::empty())
                            .unwrap())
                    }),
                }
            }
        }
        impl<T: EntityDiscovery> Clone for EntityDiscoveryServer<T> {
            fn clone(&self) -> Self {
                let inner = self.inner.clone();
                Self { inner }
            }
        }
        impl<T: EntityDiscovery> Clone for _Inner<T> {
            fn clone(&self) -> Self {
                Self(self.0.clone(), self.1.clone())
            }
        }
        impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(f, "{:?}", self.0)
            }
        }
        impl<T: EntityDiscovery> tonic::transport::NamedService for EntityDiscoveryServer<T> {
            const NAME: &'static str = "cloudstate.EntityDiscovery";
        }
    }

    pub mod eventsourced {
        use crate::cloudstate::ClientAction;

        /// The init message. This will always be the first message sent to the entity when
        /// it is loaded.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedInit {
            #[prost(string, tag = "1")]
            pub service_name: std::string::String,
            /// The ID of the entity.
            #[prost(string, tag = "2")]
            pub entity_id: std::string::String,
            /// If present the entity should initialise its state using this snapshot.
            #[prost(message, optional, tag = "3")]
            pub snapshot: ::std::option::Option<EventSourcedSnapshot>,
        }
        /// A snapshot
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedSnapshot {
            /// The sequence number when the snapshot was taken.
            #[prost(int64, tag = "1")]
            pub snapshot_sequence: i64,
            /// The snapshot.
            #[prost(message, optional, tag = "2")]
            pub snapshot: ::std::option::Option<::prost_types::Any>,
        }
        /// An event. These will be sent to the entity when the entity starts up.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedEvent {
            /// The sequence number of the event.
            #[prost(int64, tag = "1")]
            pub sequence: i64,
            /// The event payload.
            #[prost(message, optional, tag = "2")]
            pub payload: ::std::option::Option<::prost_types::Any>,
        }
        /// A reply to a command.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedReply {
            /// The id of the command being replied to. Must match the input command.
            #[prost(int64, tag = "1")]
            pub command_id: i64,
            /// The action to take
            #[prost(message, optional, tag = "2")]
            pub client_action: ::std::option::Option<super::ClientAction>,
            /// Any side effects to perform
            #[prost(message, repeated, tag = "3")]
            pub side_effects: ::std::vec::Vec<super::SideEffect>,
            /// A list of events to persist - these will be persisted before the reply
            /// is sent.
            #[prost(message, repeated, tag = "4")]
            pub events: ::std::vec::Vec<::prost_types::Any>,
            /// An optional snapshot to persist. It is assumed that this snapshot will have
            /// the state of any events in the events field applied to it. It is illegal to
            /// send a snapshot without sending any events.
            #[prost(message, optional, tag = "5")]
            pub snapshot: ::std::option::Option<::prost_types::Any>,
        }
        /// Input message type for the gRPC stream in.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedStreamIn {
            #[prost(oneof = "event_sourced_stream_in::Message", tags = "1, 2, 3")]
            pub message: ::std::option::Option<event_sourced_stream_in::Message>,
        }
        pub mod event_sourced_stream_in {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Message {
                #[prost(message, tag = "1")]
                Init(super::EventSourcedInit),
                #[prost(message, tag = "2")]
                Event(super::EventSourcedEvent),
                #[prost(message, tag = "3")]
                Command(super::super::Command),
            }
        }
        /// Output message type for the gRPC stream out.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct EventSourcedStreamOut {
            #[prost(oneof = "event_sourced_stream_out::Message", tags = "1, 2")]
            pub message: ::std::option::Option<event_sourced_stream_out::Message>,
        }
        pub mod event_sourced_stream_out {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Message {
                #[prost(message, tag = "1")]
                Reply(super::EventSourcedReply),
                #[prost(message, tag = "2")]
                Failure(super::super::Failure),
            }
        }
        #[doc = r" Generated server implementations."]
        pub mod event_sourced_server {
            #![allow(unused_variables, dead_code, missing_docs)]
            use tonic::codegen::*;
            #[doc = "Generated trait containing gRPC methods that should be implemented for use with EventSourcedServer."]
            #[async_trait]
            pub trait EventSourced: Send + Sync + 'static {
                #[doc = "Server streaming response type for the handle method."]
                type handleStream: Stream<Item = Result<super::EventSourcedStreamOut, tonic::Status>>
                    + Send
                    + Sync
                    + 'static;
                #[doc = " The stream. One stream will be established per active entity."]
                #[doc = " Once established, the first message sent will be Init, which contains the entity ID, and,"]
                #[doc = " if the entity has previously persisted a snapshot, it will contain that snapshot. It will"]
                #[doc = " then send zero to many event messages, one for each event previously persisted. The entity"]
                #[doc = " is expected to apply these to its state in a deterministic fashion. Once all the events"]
                #[doc = " are sent, one to many commands are sent, with new commands being sent as new requests for"]
                #[doc = " the entity come in. The entity is expected to reply to each command with exactly one reply"]
                #[doc = " message. The entity should reply in order, and any events that the entity requests to be"]
                #[doc = " persisted the entity should handle itself, applying them to its own state, as if they had"]
                #[doc = " arrived as events when the event stream was being replayed on load."]
                async fn handle(
                    &self,
                    request: tonic::Request<tonic::Streaming<super::EventSourcedStreamIn>>,
                ) -> Result<tonic::Response<Self::handleStream>, tonic::Status>;
            }
            #[doc = " The Entity service"]
            #[derive(Debug)]
            #[doc(hidden)]
            pub struct EventSourcedServer<T: EventSourced> {
                inner: _Inner<T>,
            }
            struct _Inner<T>(Arc<T>, Option<tonic::Interceptor>);
            impl<T: EventSourced> EventSourcedServer<T> {
                pub fn new(inner: T) -> Self {
                    let inner = Arc::new(inner);
                    let inner = _Inner(inner, None);
                    Self { inner }
                }
                pub fn with_interceptor(
                    inner: T,
                    interceptor: impl Into<tonic::Interceptor>,
                ) -> Self {
                    let inner = Arc::new(inner);
                    let inner = _Inner(inner, Some(interceptor.into()));
                    Self { inner }
                }
            }
            impl<T, B> Service<http::Request<B>> for EventSourcedServer<T>
            where
                T: EventSourced,
                B: HttpBody + Send + Sync + 'static,
                B::Error: Into<StdError> + Send + 'static,
            {
                type Response = http::Response<tonic::body::BoxBody>;
                type Error = Never;
                type Future = BoxFuture<Self::Response, Self::Error>;
                fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
                    Poll::Ready(Ok(()))
                }
                fn call(&mut self, req: http::Request<B>) -> Self::Future {
                    let inner = self.inner.clone();
                    match req.uri().path() {
                        "/cloudstate.eventsourced.EventSourced/handle" => {
                            #[allow(non_camel_case_types)]
                            struct handleSvc<T: EventSourced>(pub Arc<T>);
                            impl<T: EventSourced>
                                tonic::server::StreamingService<super::EventSourcedStreamIn>
                                for handleSvc<T>
                            {
                                type Response = super::EventSourcedStreamOut;
                                type ResponseStream = T::handleStream;
                                type Future =
                                    BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
                                fn call(
                                    &mut self,
                                    request: tonic::Request<
                                        tonic::Streaming<super::EventSourcedStreamIn>,
                                    >,
                                ) -> Self::Future {
                                    let inner = self.0.clone();
                                    let fut = async move { inner.handle(request).await };
                                    Box::pin(fut)
                                }
                            }
                            let inner = self.inner.clone();
                            let fut = async move {
                                let interceptor = inner.1;
                                let inner = inner.0;
                                let method = handleSvc(inner);
                                let codec = tonic::codec::ProstCodec::default();
                                let mut grpc = if let Some(interceptor) = interceptor {
                                    tonic::server::Grpc::with_interceptor(codec, interceptor)
                                } else {
                                    tonic::server::Grpc::new(codec)
                                };
                                let res = grpc.streaming(method, req).await;
                                Ok(res)
                            };
                            Box::pin(fut)
                        }
                        _ => Box::pin(async move {
                            Ok(http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .body(tonic::body::BoxBody::empty())
                                .unwrap())
                        }),
                    }
                }
            }
            impl<T: EventSourced> Clone for EventSourcedServer<T> {
                fn clone(&self) -> Self {
                    let inner = self.inner.clone();
                    Self { inner }
                }
            }
            impl<T: EventSourced> Clone for _Inner<T> {
                fn clone(&self) -> Self {
                    Self(self.0.clone(), self.1.clone())
                }
            }
            impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "{:?}", self.0)
                }
            }
            impl<T: EventSourced> tonic::transport::NamedService for EventSourcedServer<T> {
                const NAME: &'static str = "cloudstate.eventsourced.EventSourced";
            }
        }
    }
}
