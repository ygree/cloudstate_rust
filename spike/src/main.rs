// autogenerated from proto files

use std::convert::Infallible;

use protocols::cloudstate::eventsourced::event_sourced_server::EventSourced;
use protocols::cloudstate::eventsourced::{EventSourcedStreamIn, EventSourcedStreamOut};
use tonic::{Status, Streaming, Response, Request};

struct MyEventSourced;

impl EventSourced for MyEventSourced {
    type handleStream = ();

    async fn handle(&self, request: Request<Streaming<EventSourcedStreamIn>>) -> Result<Response<Self::handleStream>, Status> {
        unimplemented!()
    }
}

pub struct AddLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

pub struct RemoveLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
}

pub struct GetShoppingCart {
    // message fields
    pub user_id: ::std::string::String,
}

// this also used in events

trait Message {}

#[derive(PartialEq, Clone, Default, Debug)]
pub struct LineItem {
    // message fields
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

// this also used as a state snapshot
#[derive(PartialEq, Clone, Default, Debug)]
pub struct Cart {
    // message fields
    // pub items: ::protobuf::RepeatedField<LineItem>,
    pub items: Vec<LineItem>,
}

impl Message for Cart {}

// autogenerated events, state (for snapshots)

pub struct ItemAdded {
    // message fields
    // pub item: ::protobuf::SingularPtrField<LineItem>,
    pub item: Option<LineItem>,
}

impl Message for ItemAdded {}

pub struct ItemRemoved {
    // message fields
    pub productId: ::std::string::String,
}

impl Message for ItemRemoved {}

// user defined command and event handlers

struct Context {}

impl Context {
    fn persist_event<T: Message>(&mut self, event: T) {}
}

trait Entity {
    type Snapshot;
    fn snapshot(self: &Self) -> Self::Snapshot;
    fn restore(snapshot: Self::Snapshot) -> Self;
    fn empty() -> Self;
}

// entity state
struct ShopCart {
    items: Vec<LineItem>,
}

// mandatory entity methods
impl Entity for ShopCart {
    type Snapshot = Cart;

    fn snapshot(self: &Self) -> Self::Snapshot {
        self.get_cart()
    }

    fn restore(cart: Self::Snapshot) -> Self {
        ShopCart { items: cart.items }
    }

    fn empty() -> Self {
        ShopCart { items: vec![] }
    }
}

//TODO bind command handlers with the gRPC service implementation
//TODO bind event handlers with the command handlers to persist events
impl ShopCart {
    // command handler
    fn add_item(self: &ShopCart, item: LineItem, ctx: &mut Context) {
        //NOTE. cart is read only
        let evt = ItemAdded { item: Some(item) };
        ctx.persist_event(evt);
    }

    // read-only command handler
    fn get_cart(self: &ShopCart) -> Cart {
        Cart {
            items: self.items.clone(),
        }
    }

    // event handler
    fn item_added(self: &mut ShopCart, event: ItemAdded) {
        if let Some(item) = event.item {
            //TODO find if it already exists
            self.items.push(item);
        }
    }

    // event handler
    fn item_removed(self: &mut ShopCart, event: ItemRemoved) {
        //TODO find and remove item by event.productId
    }
}

fn main() {
    let cart = Cart {
        items: vec![LineItem {
            product_id: "1234".to_string(),
            name: "Milk".to_string(),
            quantity: 1,
        }],
    };

    let entity = ShopCart::restore(cart.clone());

    let cart1 = entity.get_cart();

    assert_eq!(cart, cart1);

    // entity.add_item()
}
