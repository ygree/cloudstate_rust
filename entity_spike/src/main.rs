// TODO: autogenerate from proto files

use std::convert::Infallible;

pub struct AddLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

pub struct RemoveLineItem {
    // message fields
    pub user_id: ::std::string::String,
    pub product_id: ::std::string::String,
}

pub struct GetShoppingCart {
    // message fields
    pub user_id: ::std::string::String,
}

// this also used in events

trait Message {}

#[derive(PartialEq, Clone, Default, Debug)]
pub struct LineItem {
    // message fields
    pub product_id: ::std::string::String,
    pub name: ::std::string::String,
    pub quantity: i32,
}

// this also used as a state snapshot
#[derive(PartialEq, Clone, Default, Debug)]
pub struct Cart {
    // message fields
    // pub items: ::protobuf::RepeatedField<LineItem>,
    pub items: Vec<LineItem>,
}

impl Message for Cart {}

// autogenerated events, state (for snapshots)

pub struct ItemAdded {
    // message fields
    // pub item: ::protobuf::SingularPtrField<LineItem>,
    pub item: Option<LineItem>,
}

impl Message for ItemAdded {}

pub struct ItemRemoved {
    // message fields
    pub productId: ::std::string::String,
}

impl Message for ItemRemoved {}

// user defined command and event handlers

struct Context {}

impl Context {
    fn persist_event<T: Message>(&mut self, event: T) {}
}

trait Entity {
    type Snapshot;
    fn snapshot(self: &Self) -> Self::Snapshot;
    fn restore(snapshot: Self::Snapshot) -> Self;
    fn empty() -> Self;
}

// entity state
struct ShopCart {
    items: Vec<LineItem>,
}

// mandatory entity methods
impl Entity for ShopCart {
    type Snapshot = Cart;

    fn snapshot(self: &Self) -> Self::Snapshot {
        self.get_cart()
    }

    fn restore(cart: Self::Snapshot) -> Self {
        ShopCart { items: cart.items }
    }

    fn empty() -> Self {
        ShopCart { items: vec![] }
    }
}

//TODO bind command handlers with the gRPC service implementation
//TODO bind event handlers with the command handlers to persist events
impl ShopCart {
    // command handler
    fn add_item(&self, item: LineItem, ctx: &mut Context) {
        //NOTE. cart is read only
        let evt = ItemAdded { item: Some(item) };
        ctx.persist_event(evt);
    }

    // read-only command handler
    fn get_cart(&self) -> Cart {
        Cart {
            items: self.items.clone(),
        }
    }

    // event handler
    fn item_added(&mut self, event: ItemAdded) {
        if let Some(item) = event.item {
            //TODO find if it already exists
            self.items.push(item);
        }
    }

    // event handler
    fn item_removed(&mut self, event: ItemRemoved) {
        //TODO find and remove item by event.productId
    }
}

mod multi_state_shop_cart {
    // experiment with multi-state behavior

    use super::{LineItem, Context, ItemAdded};

    enum ShopCartState {
        Empty(ShopCartEmpty),
        Open(ShopCartOpen),
        Closed(ShopCartClosed),
    }

    struct ShopCartEmpty();
    impl ShopCartBehavior for ShopCartEmpty {
        //use default behavior
    }

    struct ShopCartOpen {
        items: Vec<LineItem>,
    }
    impl ShopCartBehavior for ShopCartOpen {
        //use default behavior
    }

    struct ShopCartClosed();
    impl ShopCartBehavior for ShopCartClosed {
        fn add_item(&self, item: LineItem, ctx: &mut Context) {
            //TODO return an error on the attempt to add item into a closed shopcart
        }
    }

    // behavior trait with default implementations
    trait ShopCartBehavior {
        fn add_item(&self, item: LineItem, ctx: &mut Context) {
            let evt = ItemAdded { item: Some(item) };
            ctx.persist_event(evt);
        }
    }

    // behavior dispatcher (should be possible to generate with a macro)
    impl ShopCartBehavior for ShopCartState {
        fn add_item(&self, item: LineItem, ctx: &mut Context) {
            match self {
                ShopCartState::Empty(state) => state.add_item(item, ctx),
                ShopCartState::Open(state) => state.add_item(item, ctx),
                ShopCartState::Closed(state) => state.add_item(item, ctx),
            }
        }
    }


    trait ShopCartEventHandler {
        fn item_added(&mut self, event: ItemAdded) {}
    }

    impl ShopCartEventHandler for ShopCartState {
        fn item_added(&mut self, event: ItemAdded) {
            if let Some(item) = event.item {
                match self {
                    ShopCartState::Empty(state) => {
                        // State transition can only be done in the dispatcher handler because
                        // specialized handler won't have access to ShopCartState.
                        *self = ShopCartState::Open(ShopCartOpen{
                            items: vec![item],
                        });
                    },
                    ShopCartState::Open(state) => {
                        state.items.push(item);
                    },
                    ShopCartState::Closed(state) => {
                        //TODO what if unexpected event received?
                        // Maybe signal about event log inconsistency for the current entity.
                        // Needed some context for that.
                    },
                }
            }
        }
    }
}

fn main() {
    let cart = Cart {
        items: vec![LineItem {
            product_id: "1234".to_string(),
            name: "Milk".to_string(),
            quantity: 1,
        }],
    };

    let entity = ShopCart::restore(cart.clone());

    let cart1 = entity.get_cart();

    assert_eq!(cart, cart1);

    // entity.add_item()
}
